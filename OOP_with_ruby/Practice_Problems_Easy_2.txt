1. You are given the following code:

class Oracle
  def predict_the_future
    "You will " + choices.sample
  end

  def choices
    ["eat a nice lunch", "take a nap soon", "stay at work late"]
  end
end
What is the result of executing the following code:

oracle = Oracle.new
oracle.predict_the_future

A: In the `predict_the_future` method, `choices` will call the `choices` method, which will return the array object `["eat a nice lunch", "take a nap soon", "stay at work late"]'. Then that array object will call the `sample` method, which will return an element randomly selected from itself. All the elements in the array are strings, so `"You will " + choices.sample` will return a concatenation of "You will " and the return value of `choices.sample`. So `predict_the_future` will return either "You will eat a nice lunch", "You will take a nap soon" or "You will stay at work late".

2. We have an Oracle class and a RoadTrip class that inherits from the Oracle class.

class Oracle
  def predict_the_future
    "You will " + choices.sample
  end

  def choices
    ["eat a nice lunch", "take a nap soon", "stay at work late"]
  end
end

class RoadTrip < Oracle
  def choices
    ["visit Vegas", "fly to Fiji", "romp in Rome"]
  end
end
What is the result of the following:

trip = RoadTrip.new
trip.predict_the_future

A: The `predict_the_future` method is inherited from the `Oracle` class. However, it contains a call to the `choices` method, which has been overridden in the `RoadTrip` class. This overridden version of `choices` is what will be called when an instance of the `RoadTrip` class calls `predict_the_future`. So `choices` will return a randomly selected string object from among its members, `["visit Vegas", "fly to Fiji", "romp in Rome"]`. And `trip.predict_the_future` will return "You will " concatenated with that randomly selected string object. So the final result will be either "You will visit Vegas", "You will fly to Fiji" or "You will romp in Rome".

3. How do you find where Ruby will look for a method when that method is called? How can you find an object's ancestors?

module Taste
  def flavor(flavor)
    puts "#{flavor}"
  end
end

class Orange
  include Taste
end

class HotSauce
  include Taste
end
What is the lookup chain for Orange and HotSauce?

A. You can call the `ancestors` method on an object's class to find the lookup chain for when a method is called on that object.
```
hot_sauce = HotSauce.new
hot_sauce.class.ancestors # => [HotSauce, Taste, Object, Kernel, BasicObject]
orange = Orange.new
orange.class.ancestors # => [Orange, Taste, Object, Kernel, BasicObject]
```
This tells you that if `hot_sauce.some_method` is called, it will look for `some_method` in the classes `HotSauce`, `Taste`, `Object`, `Kernel` and `BasicObject` in that order. For `orange.some_method`, the lookup chain will be `Orange`, `Taste`, `Object`, `Kernel` and `BasicObject`.

4. What could you add to this class to simplify it and remove two methods from the class definition while still maintaining the same functionality?

class BeesWax
  def initialize(type)
    @type = type
  end

  def type
    @type
  end

  def type=(t)
    @type = t
  end

  def describe_type
    puts "I am a #{@type} of Bees Wax"
  end
end

A:
```
class BeesWax
  attr_accessor :type
  def initialize(type)
    @type = type
  end

  def describe_type
    puts "I am a #{type} of Bees Wax"
  end
end
```
Note: If a getter method for an instance variable is available, it is standard practice to call the method rather than referring to the instance variable directly. So since `type` is available as a getter method for `@type`, we can substitute `#{type}` for `#{@type}` in the `describe_type` method.

5. There are a number of variables listed below. What are the different types and how do you know which is which?

excited_dog = "excited dog"
@excited_dog = "excited dog"
@@excited_dog = "excited dog"

A: We know that Ruby will initialize `excited_dog` as a local variable because it starts with a lowercase letter rather than a capital letter, one '@' sign or two '@' signs. `@excited dog` will be initialized as an instance variable because it starts with one '@' sign. `@@excited_dog` will be initialized as a class variable because it starts with two '@' signs.

6. If I have the following class:

class Television
  def self.manufacturer
    # method logic
  end

  def model
    # method logic
  end
end
Which one of these is a class method (if any) and how do you know? How would you call a class method?

A: Television::manufacturer is the class method. You can tell by the way the `def` statement has a `self` in it. If it said `def manufacturer` instead of `def self.manufacturer` it would be an instance method. To call this class method, you must enter `Television.manufacturer`.

7. If we have a class such as the one below:

class Cat
  @@cats_count = 0

  def initialize(type)
    @type = type
    @age  = 0
    @@cats_count += 1
  end

  def self.cats_count
    @@cats_count
  end
end
Explain what the @@cats_count variable does and how it works. What code would you need to write to test your theory?

A: The `initialize` method is called every time a new instance of the `Cat` class is created. Every time this method is called, the class variable `@@cats_count ` is incremented by one. The `Cat::cats_count` method is a getter for this class variable. Before any `Cat` objects have been created, `Cat.cats_count` will return 0. After a call to `Cat::new` such as `Cat.new('Persian')`, `Cat.cats_count` will return 1, and so on. You can test it like this:

```
Cat.cats_count # => 0
Cat.new('Persian')
Cat.cats_count # => 1
Cat.new('Siamese')
Cat.cats_count # => 2
```

8. If we have this class:

class Game
  def play
    "Start the game!"
  end
end

And another class:

class Bingo
  def rules_of_play
    #rules of play
  end
end

What can we add to the Bingo class to allow it to inherit the play method from the Game class?

A: `class Bingo < Game`

9. What would happen if we added a play method to the Bingo class, keeping in mind that there is already a method of this name in the Game class that the Bingo class inherits from?

A: The `play` method defined in the `Bingo` class would override the `play` method defined in the `Game` class. Therefore, `Bingo.new.play` would be a call to the `play` method defined in the `Bingo` class, rather than the one defined in the `Game` class.
